import { NextRequest, NextResponse } from 'next/server';
import fs from 'fs';
import path from 'path';
import GoogleDriveService from '@/lib/googleDrive';
import { instructionsCache } from '@/lib/instructionsCache';
import { GoogleGenerativeAI } from '@google/generative-ai';

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY || '');

// Safe directory creation for different environments
function getSafeInstructionsDir(): string | null {
  try {
    // For Vercel and other serverless environments, use /tmp
    if (process.env.VERCEL || process.env.AWS_LAMBDA_FUNCTION_NAME) {
      const tmpDir = '/tmp/instructions';
      if (!fs.existsSync(tmpDir)) {
        fs.mkdirSync(tmpDir, { recursive: true });
      }
      return tmpDir;
    }
    
    // For local development
    const localDir = path.join(process.cwd(), 'instructions');
    if (!fs.existsSync(localDir)) {
      fs.mkdirSync(localDir, { recursive: true });
    }
    return localDir;
  } catch (error) {
    console.warn('Cannot create instructions directory, using memory-only storage:', error);
    return null;
  }
}

export async function POST(request: NextRequest) {
  let tempFilePath: string | null = null;
  
  try {
    const formData = await request.formData();
    const file = formData.get('instruction') as File;
    const customPrompt = formData.get('customPrompt') as string;
    
    if (!file) {
      return NextResponse.json({ error: 'No instruction file provided' }, { status: 400 });
    }

    // Read file content - try to extract text from various file types
    const bytes = await file.arrayBuffer();
    let content: string;
    
    // For text-based files, read as UTF-8
    const textExtensions = ['.txt', '.md', '.csv', '.json', '.xml', '.js', '.ts', '.html', '.css'];
    const isTextFile = textExtensions.some(ext => file.name.toLowerCase().endsWith(ext));
    
    if (isTextFile) {
      content = Buffer.from(bytes).toString('utf-8');
    } else {
      // For binary files, store a placeholder message
      content = `[Binary file: ${file.name}] - Content will be processed by AI when analyzing files.`;
    }
    
    // Generate unique ID for the instruction file
    const instructionId = `instruction_${Date.now()}`;
    
    // Save to temporary file for Google Drive upload
    const tempDir = '/tmp';
    tempFilePath = path.join(tempDir, `${instructionId}.txt`);
    fs.writeFileSync(tempFilePath, content);
    
    // Try to upload to Google Drive (required for serverless)
    let driveFile = null;
    try {
      const driveService = new GoogleDriveService();
      driveFile = await driveService.uploadFile(
        tempFilePath,
        `${instructionId}_${file.name}`,
        'text/plain'
      );
      
      if (!driveFile.success) {
        console.warn('Google Drive upload failed:', driveFile.error);
      }
    } catch (error) {
      console.warn('Google Drive upload failed:', error);
      driveFile = { success: false, error: 'Upload failed' };
    }

    // Detect special instructions and PMP-A files
    const isSpecialInstruction = content.toLowerCase().includes('special instruction') || 
                                content.toLowerCase().includes('priority instruction') ||
                                content.toLowerCase().includes('important note');
    const isPMPAFile = file.name.toLowerCase().includes('pmp-a') || 
                      file.name.toLowerCase().includes('pmp_a') ||
                      content.toLowerCase().includes('pmp-a');
    
    // Extract special instruction content if present
    let specialInstructionContent = '';
    if (isSpecialInstruction) {
      const lines = content.split('\n');
      const specialLines = lines.filter(line => 
        line.toLowerCase().includes('special') || 
        line.toLowerCase().includes('priority') ||
        line.toLowerCase().includes('important')
      );
      specialInstructionContent = specialLines.join('\n');
    }

    // Generate AI feedback automatically using Gemini for all files
    let autoGeneratedFeedback = '';
    if (process.env.GEMINI_API_KEY && isTextFile) { // Only generate for text files
      try {
        const instructionType = isPMPAFile ? 'PMP-A (Project Management Professional - Assessment)' : 'general instruction';
        const isExcelFile = file.name.toLowerCase().endsWith('.xlsx') || file.name.toLowerCase().endsWith('.xls');
        const isSpreadsheetData = content.includes('BDM_PMPA.xlsx') || content.includes('PMP-A') || isExcelFile;
        
        const feedbackPrompt = `You are an expert data analyst and project management consultant reviewing a ${instructionType} instruction file.

FILE INFORMATION:
- File Name: ${file.name}
- Type: ${isExcelFile ? 'Excel Spreadsheet' : 'Text Document'}
- Contains PMP-A Data: ${isPMPAFile ? 'Yes' : 'No'}

INSTRUCTION CONTENT:
${content}

${customPrompt ? `CUSTOM ANALYSIS INSTRUCTIONS: ${customPrompt}` : ''}

${isSpreadsheetData ? `
SPECIAL INSTRUCTIONS FOR SPREADSHEET ANALYSIS:
Since this appears to involve Excel/spreadsheet data, provide specific recommendations for:
- Data validation techniques for spreadsheet columns
- Excel-specific validation tools and formulas
- How to handle multi-tab/sheet analysis (especially PMP-A tabs)
- Recommendations for data quality checks in spreadsheet format
- Specific steps to analyze the actual data within Excel files
` : ''}

Please provide comprehensive feedback covering:

1. **Content Analysis**: 
   - Clarity and completeness of the instructions
   - Specific gaps or ambiguities identified
   ${isSpreadsheetData ? '- Spreadsheet-specific data validation recommendations' : ''}

2. **Structure and Organization**: 
   - How well-organized and logical is the content?
   - Suggested improvements for better flow
   ${isExcelFile ? '- Recommendations for multi-sheet analysis approach' : ''}

3. **${isPMPAFile ? 'PMP-A Standards Compliance' : 'Best Practices Alignment'}**: 
   ${isPMPAFile ? '- Alignment with PMP-A assessment criteria and standards' : '- Adherence to industry best practices for instruction writing'}
   - Areas where standards could be better addressed

4. **Actionability and Implementation**: 
   - How actionable and specific are the instructions?
   - Missing steps or procedures that should be included
   ${isSpreadsheetData ? '- Specific Excel tools and functions that could be utilized' : ''}

5. **Data Quality Recommendations** ${isSpreadsheetData ? '(Excel-Focused)' : ''}:
   ${isSpreadsheetData ? 
     `- Specific validation rules for Excel columns and data types
   - Cross-field validation strategies for related data
   - Automated validation approaches using Excel features
   - Data profiling and quality assessment techniques
   - How to access and analyze actual data within Excel tabs/sheets` : 
     '- General data quality considerations and validation approaches'}

6. **Practical Implementation Steps**:
   - Concrete next steps for implementing these instructions
   - Tools and resources needed
   ${isSpreadsheetData ? '- Excel-specific implementation guidance for accessing actual data' : ''}

IMPORTANT: If the instructions mention specific Excel files (like BDM_PMPA.xlsx) but don't provide access to the actual data, recommend specific steps for obtaining and analyzing that data. Provide actionable guidance that doesn't require seeing the actual spreadsheet content.

PROVIDE SPECIFIC, ACTIONABLE RECOMMENDATIONS. Format your response with clear sections and bullet points for easy implementation.`;

        const model = genAI.getGenerativeModel({ model: "gemini-1.5-flash" });
        const result = await model.generateContent(feedbackPrompt);
        const response = await result.response;
        autoGeneratedFeedback = response.text() || '';
        
        console.log('Generated AI feedback successfully for:', instructionId);
      } catch (error) {
        console.warn('Failed to generate automatic AI feedback:', error);
        autoGeneratedFeedback = '';
      }
    }

    // Store in memory cache for this session
    const instructionData = {
      id: instructionId,
      fileName: file.name,
      content,
      publicUrl: driveFile?.publicUrl || null,
      directUrl: driveFile?.directUrl || null,
      fileId: driveFile?.fileId || null,
      createdAt: new Date().toISOString(),
      hasGoogleDriveBackup: driveFile?.success || false,
      specialInstruction: isSpecialInstruction ? specialInstructionContent : undefined,
      isPMPA: isPMPAFile,
      feedback: autoGeneratedFeedback || '', // Include feedback for all files
      inputData: isPMPAFile ? {} : undefined,
      customPrompt: customPrompt || undefined,
    };
    
    instructionsCache.set(instructionId, instructionData);
    
    // Try to save locally if possible (for local development)
    const instructionsDir = getSafeInstructionsDir();
    if (instructionsDir) {
      try {
        const localPath = path.join(instructionsDir, `${instructionId}.txt`);
        const metadataPath = path.join(instructionsDir, `${instructionId}.meta.json`);
        fs.writeFileSync(localPath, content);
        fs.writeFileSync(metadataPath, JSON.stringify(instructionData, null, 2));
      } catch (error) {
        console.warn('Could not save locally, relying on memory and Google Drive:', error);
      }
    }

    return NextResponse.json({
      success: true,
      instructionId,
      fileName: file.name,
      content,
      driveFile,
      publicUrl: driveFile?.publicUrl || null,
      directUrl: driveFile?.directUrl || null,
      message: driveFile && driveFile.success ? 
        'File uploaded successfully with Google Drive backup' : 
        'File stored in session (configure Google Drive for persistence)',
    });

  } catch (error) {
    console.error('Error uploading instruction file:', error);
    return NextResponse.json(
      { error: 'Failed to upload instruction file' },
      { status: 500 }
    );
  } finally {
    // Clean up temporary file
    if (tempFilePath && fs.existsSync(tempFilePath)) {
      try {
        fs.unlinkSync(tempFilePath);
      } catch (error) {
        console.warn('Failed to clean up temp file:', error);
      }
    }
  }
}

export async function GET() {
  try {
    interface InstructionItem {
      id: string;
      content: string;
      fullContent: string;
      createdAt: Date;
      size: number;
      publicUrl: string | null;
      directUrl: string | null;
      fileId: string | null;
      fileName: string;
      hasGoogleDriveBackup: boolean;
      specialInstruction?: string;
      isPMPA?: boolean;
      feedback?: string;
      inputData?: Record<string, string>;
      customPrompt?: string;
    }
    
    let instructions: Array<InstructionItem> = [];
    
    // First, try to get from memory cache
    const cacheInstructions = Array.from(instructionsCache.values()).map(item => ({
      id: item.id,
      content: item.content.substring(0, 200) + (item.content.length > 200 ? '...' : ''),
      fullContent: item.content,
      createdAt: new Date(item.createdAt),
      size: item.content.length,
      publicUrl: item.publicUrl,
      directUrl: item.directUrl,
      fileId: item.fileId,
      fileName: item.fileName,
      hasGoogleDriveBackup: item.hasGoogleDriveBackup,
      specialInstruction: item.specialInstruction,
      isPMPA: item.isPMPA,
      feedback: item.feedback,
      inputData: item.inputData,
      customPrompt: item.customPrompt,
    }));
    
    instructions = [...cacheInstructions];
    
    // Also try to read from filesystem if available (for local development)
    const instructionsDir = getSafeInstructionsDir();
    if (instructionsDir) {
      try {
        const files = fs.readdirSync(instructionsDir);
        const fileInstructions = files
          .filter(file => file.endsWith('.meta.json'))
          .map(file => {
            const instructionId = file.replace('.meta.json', '');
            
            // Skip if already in cache
            if (instructionsCache.has(instructionId)) {
              return null;
            }
            
            try {
              const metadataPath = path.join(instructionsDir, file);
              const metadata = JSON.parse(fs.readFileSync(metadataPath, 'utf-8'));
              
              // Add to cache for future requests
              instructionsCache.set(instructionId, metadata);
              
              return {
                id: metadata.id,
                content: metadata.content.substring(0, 200) + (metadata.content.length > 200 ? '...' : ''),
                fullContent: metadata.content,
                createdAt: new Date(metadata.createdAt),
                size: metadata.content.length,
                publicUrl: metadata.publicUrl || null,
                directUrl: metadata.directUrl || null,
                fileId: metadata.fileId || null,
                fileName: metadata.fileName || instructionId,
                hasGoogleDriveBackup: metadata.hasGoogleDriveBackup || false,
                specialInstruction: metadata.specialInstruction,
                isPMPA: metadata.isPMPA,
                feedback: metadata.feedback,
                inputData: metadata.inputData,
                customPrompt: metadata.customPrompt,
              };
            } catch (error) {
              console.warn('Error reading instruction metadata file:', file, error);
              return null;
            }
          })
          .filter((instruction): instruction is NonNullable<typeof instruction> => instruction !== null);
        
        instructions = [...instructions, ...fileInstructions];
      } catch (error) {
        console.warn('Could not read from filesystem, using cache only:', error);
      }
    }
    
    // Sort by creation date
    instructions.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());

    return NextResponse.json({
      success: true,
      instructions,
    });

  } catch (error) {
    console.error('Error fetching instruction files:', error);
    return NextResponse.json(
      { error: 'Failed to fetch instruction files' },
      { status: 500 }
    );
  }
}

export async function PATCH(request: NextRequest) {
  try {
    const body = await request.json();
    const { id, feedback, inputData, content, customPrompt } = body;
    
    if (!id) {
      return NextResponse.json({ error: 'Instruction ID is required' }, { status: 400 });
    }
    
    // Get existing instruction from cache
    const existingInstruction = instructionsCache.get(id);
    if (!existingInstruction) {
      return NextResponse.json({ error: 'Instruction not found' }, { status: 404 });
    }
    
    // Update the instruction data
    const updatedInstruction = {
      ...existingInstruction,
      ...(feedback !== undefined && { feedback }),
      ...(inputData !== undefined && { inputData }),
      ...(content !== undefined && { content }),
      ...(customPrompt !== undefined && { customPrompt }),
    };
    
    // Update in cache
    instructionsCache.set(id, updatedInstruction);
    
    // Try to update local file if possible
    const instructionsDir = getSafeInstructionsDir();
    if (instructionsDir) {
      try {
        const metadataPath = path.join(instructionsDir, `${id}.meta.json`);
        if (fs.existsSync(metadataPath)) {
          fs.writeFileSync(metadataPath, JSON.stringify(updatedInstruction, null, 2));
        }
        
        // Update content file if content was changed
        if (content !== undefined) {
          const contentPath = path.join(instructionsDir, `${id}.txt`);
          if (fs.existsSync(contentPath)) {
            fs.writeFileSync(contentPath, content);
          }
        }
      } catch (error) {
        console.warn('Could not update local files:', error);
      }
    }
    
    return NextResponse.json({
      success: true,
      message: 'Instruction updated successfully',
      instruction: updatedInstruction,
    });
    
  } catch (error) {
    console.error('Error updating instruction:', error);
    return NextResponse.json(
      { error: 'Failed to update instruction' },
      { status: 500 }
    );
  }
}

export async function DELETE(request: NextRequest) {
  try {
    const url = new URL(request.url);
    const id = url.searchParams.get('id');
    
    if (!id) {
      return NextResponse.json({ error: 'Instruction ID is required' }, { status: 400 });
    }
    
    // Check if instruction exists in cache
    const existingInstruction = instructionsCache.get(id);
    if (!existingInstruction) {
      return NextResponse.json({ error: 'Instruction not found' }, { status: 404 });
    }
    
    // Remove from cache
    instructionsCache.delete(id);
    
    // Try to delete local files if possible
    const instructionsDir = getSafeInstructionsDir();
    if (instructionsDir) {
      try {
        const contentPath = path.join(instructionsDir, `${id}.txt`);
        const metadataPath = path.join(instructionsDir, `${id}.meta.json`);
        
        if (fs.existsSync(contentPath)) {
          fs.unlinkSync(contentPath);
        }
        if (fs.existsSync(metadataPath)) {
          fs.unlinkSync(metadataPath);
        }
      } catch (error) {
        console.warn('Could not delete local files:', error);
      }
    }
    
    return NextResponse.json({
      success: true,
      message: 'Instruction deleted successfully',
    });
    
  } catch (error) {
    console.error('Error deleting instruction:', error);
    return NextResponse.json(
      { error: 'Failed to delete instruction' },
      { status: 500 }
    );
  }
}
